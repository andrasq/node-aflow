/**
 * Flow control library to simplify sequencing calls with callbacks.
 *
 * Similar to async, but faster and more robust.  Notable differences:
 *   - no more "call stack exceeded" from callbacks
 *   - callbacks must be called
 *   - callbacks can use process.nextTick without recursion
 *   - loop overhead is less
 *   - waterfall and series are combined
 *
 * Copyright (C) 2014 Andras Radics
 * Licensed under the Apache License, Version 2.0
 *
 * 2014-09-28 - AR.
 */

module.exports.repeatUntil = repeatUntil;
module.exports.applyVisitor = applyVisitor;
module.exports.repeatWhile = repeatWhile;
module.exports.map = map;
module.exports.filter = filter;
module.exports.reduce = reduce;
module.exports.iterate = module.exports.sequence = iterate;
// aliases
module.exports.qflow = iterate;
module.exports.flow = iterate;
module.exports.select = filter;
module.exports.series = iterate;
module.exports.whilst = repeatWhile;

var qflowSetImmediate = global.setImmediate || process.nextTick

/**
 * Repeatedly call func until it signals stop (returns truthy) or err.
 * Func is passed just a standard callback taking err and ret.
 * Returns via its callback the truthy value from func.
 */
function repeatUntil( func, callback ) {
    'use strict';

    callback = callback || function() {};
    var alreadyReturned;

    function _loop( callDepth ) {
        try {
            func( function(err, stop) {
                if (err || stop) {
                    alreadyReturned = err || stop;
                    return callback(err, stop);
                }
                else if (callDepth < 40) {
                    _loop(callDepth + 1);
                }
                else {
                    qflowSetImmediate(function() { _loop(0); });
                }
            } );
        }
        catch (e) {
            // be sure to not call the callback more than once, and do not
            // inject errors from within the callback back into the callback.
            // If the callback throws while still in our try/catch block,
            // re-throw it as if it were coming from inside a setImmediate.
            if (!alreadyReturned) {
                callback(alreadyReturned = e);
            }
            else {
                throw e;
            }
        }
    }

    _loop(0);
}

/**
 * Repeatedly call func as long as test returns truthy.
 */
function repeatWhile( test, func, callback ) {
    repeatUntil(
        function _loop(cb) {
            if (test()) func(function(err) { cb(err, false); });
            else cb(null, true);
        },
        callback
    );
}

/**
 * visitor pattern: present all items to the visitor function.
 * Returns just error status, no data; to capture the results,
 * wrapper the visitor function.
 */
function applyVisitor( dataItems, visitorFunction, callback ) {
    'use strict';

    if (!dataItems || typeof dataItems.length !== 'number') {
        return callback(new Error("expected a data array, but got " + typeof data));
    }

    var next = 0;
    repeatUntil(
        function applyFunc(cb) {
            if (next >= dataItems.length) return cb(null, true);
            visitorFunction(dataItems[next++], function(err) {
                cb(err, err);
            });
        },
        function(err, stop) {
            callback(err);
        }
    );
}

/**
 * Run the list of functions, calling each one in turn.
 * Each function is passed a callback and the data item
 * returned by the previous function.  Errors interrupt the flow.
 * The final result is the last result generated by the sequence
 * (and not all the individual results).
 */
function iterate( functionList, callback ) {
    'use strict';

    var lastResult, lastResult2;
    var callReturned;
    applyVisitor(
        functionList,
        function visitor(func, cb) {
            // send this computed result right back to the visitor loop,
            // it will become the next func`s lastResult
            // forwards the first 2 results to the next function in the chain
            callReturned = false;
            func(
                function(err, ret, ret2) {
                    callReturned = true;
                    lastResult = ret;
                    lastResult2 = ret2;
                    cb(err, ret, ret2);
                },
                lastResult,
                lastResult2
            );
        },
        function(err, ret) {
            // return the very last result computed, that applyVisitor returns
            return callback ? (callReturned ? callback(err, lastResult, lastResult2) : callback(err)) : null;
        }
    );
}

/**
 * Combine all items in the data array using func.
 * runningTotal is the initial combined value; a call to combinerFunc is given
 * the running total and item and the return value is the new runningTotal.
 * This is an async variant of Array.prototype.reduce().
 */
function reduce( data, runningTotal, combinerFunc, callback ) {
    'use strict';

    applyVisitor(
        data,
        function visitor(item, cb) {
            combinerFunc(runningTotal, item, function(err, ret) {
                // the running total is the combined results of item and the
                // previous subtotal, as computed by func().
                if (!err || ret !== undefined) runningTotal = ret;
                return cb(err, runningTotal);
            });
        },
        function(err, ret) {
            callback(err, runningTotal);
        }
    );
}

/**
 * Apply the function func to all the items in data, and return the
 * results produced.  Func must take a single argument and a callback.
 * In case of error returns the partial results so far;
 * the very last returned result is the one that errored out.
 */
function map( data, mapperFunc, callback ) {
    // TODO: might also want to map properties of an object, not just arrays
    // Approach: convert object to list, map list, de-convert results.

    var mappedResults = [];
    applyVisitor(
        data,
        function visitor(item, cb) {
            mapperFunc(item, function(err, mappedItem) {
                if (!err || mappedItem !== undefined) mappedResults.push(mappedItem);
                cb(err);
            });
        },
        function(err, ret) {
            return callback(err, mappedResults);;
        }
    );
}

/**
 * Return the list of items that were picked by the filter function.
 * The filter function should return truthy for values to include,
 * and falsy for values to omit from the results.
 */
function filter( data, filterFunc, callback ) {
    var pickedItems = [];
    applyVisitor(
        data,
        function visitor(item, cb) {
            filterFunc(item, function(err, yesno) {
                if (yesno) pickedItems.push(item);
                cb(err);
            });
        },
        function(err) {
            callback(err, pickedItems);
        }
    );
}
